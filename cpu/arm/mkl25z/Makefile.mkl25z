# Code common for all ARM CPUs
CONTIKI_CPU_ARM=$(CONTIKI)/cpu/arm
CONTIKI_CPU_ARM_COMMON=$(CONTIKI_CPU_ARM)/common

# Define the CPU directory
CONTIKI_CPU=$(CONTIKI_CPU_ARM)/mkl25z
MCU = cortex-m0plus

CC      = arm-none-eabi-gcc
CPP     = arm-none-eabi-cpp
CP      = arm-none-eabi-objcopy
LD      = arm-none-eabi-ld
AR      = arm-none-eabi-ar
OBJCOPY = arm-none-eabi-objcopy
OBJDUMP = arm-none-eabi-objdump
NM      = arm-none-eabi-nm
SIZE    = arm-none-eabi-size
STRIP   = arm-none-eabi-strip
HEX     = $(OBJCOPY) -O ihex
BIN     = $(OBJCOPY) -O binary -S
S19     = $(OBJCOPY) -O srec

MKL25Z = watchdog.c kinetis_sysinit.c clock.c debug-uart.c rtimer-arch.c serial.c spi.c nvic.c cpu.c clock.c kinetis_sysinit.c
MKL25ZASM = startup.S

LDSCRIPT = $(CONTIKI_CPU)/MKL25Z128_flash.ld

ARCH_FLAGS = -mthumb -gdwarf-2 -fomit-frame-pointer -Wall -Wstrict-prototypes -fverbose-asm
MCFLAGS = -mcpu=$(MCU)
OPT = -O0

CFLAGS += $(MCFLAGS) $(OPT) $(ARCH_FLAGS) -Wa,-ahlms=$(<:.c=.lst)
LDFLAGS += $(MCFLAGS) -mthumb -nostartfiles -T$(LDSCRIPT) -Wl,-Map=$(FULL_PRJ).map,--cref,--no-warn-mismatch
ASFLAGS = $(MCFLAGS) -g -gdwarf-2 -mthumb -Wa,-amhls=$(<:.S=.lst)

### If the user-specified a Node ID, pass a define
ifdef NODEID
  CFLAGS += -DIEEE_ADDR_NODE_ID=$(NODEID)
endif

### CPU-dependent cleanup files
CLEAN += symbols.c symbols.h *.d *.elf *.hex *.srec *.s19

### CPU-dependent directories
CONTIKI_CPU_DIRS = . ../arm/common/dbg-io

### CPU-dependent source files
DEBUG_IO_SOURCEFILES += dbg-printf.c dbg-puts.c dbg-putchar.c dbg-snprintf.c dbg-sprintf.c strformat.c

CONTIKI_SOURCEFILES += $(MKL25Z) $(DEBUG_IO_SOURCEFILES)

PROJECT_OBJECTFILES += ${addprefix $(OBJECTDIR)/,$(CONTIKI_TARGET_MAIN:.c=.o)}
PROJECT_OBJECTFILES += ${addprefix $(OBJECTDIR)/,$(MKL25ZASM:.S=.o)}


### Don't treat the .elf as intermediate
.PRECIOUS: %.elf %.hex %.bin %.srec %.s19

### Always re-build ieee-addr.o in case the command line passes a new NODEID
FORCE:

$(OBJECTDIR)/ieee-addr.o: ieee-addr.c FORCE | $(OBJECTDIR)
	$(CC) $(CFLAGS) -c $< -o $@

### Compilation rules

%.srec: %.elf
	$(S19) %.elf $@

CUSTOM_RULE_C_TO_O=yes
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

CUSTOM_RULE_C_TO_OBJECTDIR_O=yes
$(OBJECTDIR)/%.o: %.c | $(OBJECTDIR)
	$(CC) $(CFLAGS) -c $< -o $@
	
CUSTOM_RULE_S_TO_O = yes
%.o: %.S
	$(AS) -c $(ASFLAGS) $< -o $@

CUSTOM_RULE_S_TO_OBJECTDIR_O = yes
$(OBJECTDIR)/%.o: %.S | $(OBJECTDIR)
	$(AS) -c $(ASFLAGS) $< -o $@	

CUSTOM_RULE_C_TO_CO=yes
%.co: %.c
	$(CC) $(CFLAGS) $< -c -o $@	
	
CUSTOM_RULE_C_TO_CE=yes
%.ce: %.o
	$(LD) $(LDFLAGS) --relocatable $< -o $@
	$(STRIP) -K _init -K _fini --strip-unneeded -g -x $@	
	
CUSTOM_RULE_LINK=1
%.elf: %.co $(PROJECT_OBJECTFILES) contiki-$(TARGET).a $(LDSCRIPT)
	$(CC) $(LDFLAGS) ${filter-out $(LDSCRIPT) %.a,$^} ${filter %.a,$^} -lm -o $@

%.hex: %.elf
	$(HEX) %.elf $@



### We don't really need the .hex and .bin for the .$(TARGET) but let's make
### sure they get built
%.$(TARGET): %.elf %.hex %.srec
	cp $< $@

clean: clean_cpu

.PHONY: mkl25z_clean

clean_cpu:
	-rm -rf $(BUILTSRCDIR)
	-rm -rf $(CONTIKI_PROJECT)-nosyms.$(TARGET) *.elf *.srec *.hex


